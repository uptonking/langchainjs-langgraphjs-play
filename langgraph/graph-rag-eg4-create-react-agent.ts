import { CheerioWebBaseLoader } from '@langchain/community/document_loaders/web/cheerio';
import { AIMessage, BaseMessage, isAIMessage } from '@langchain/core/messages';
import { tool } from '@langchain/core/tools';
import { createReactAgent } from '@langchain/langgraph/prebuilt';
import { ChatOpenAI, OpenAIClient } from '@langchain/openai';
import { RecursiveCharacterTextSplitter } from '@langchain/textsplitters';
import { MemoryVectorStore } from 'langchain/vectorstores/memory';
import { z } from 'zod';

// üßë‚Äçüè´ [Build a RAG App: Part 2](https://js.langchain.com/docs/tutorials/qa_chat_history/)

const llm = new ChatOpenAI({
  // model: 'qwen/qwen3-4b-2507',
  model: 'google/gemma-3-12b',
  configuration: {
    baseURL: 'http://localhost:1234/v1',
    apiKey: 'not-needed',
  },
  temperature: 0,
});

// const embeddings = new OpenAIEmbeddings({
//   model: "text-embedding-qwen3-embedding-0.6b",
//   // model: 'text-embedding-embeddinggemma-300m',
//   configuration: {
//     baseURL: 'http://localhost:1234/v1',
//     // check: false,
//     apiKey: 'not-needed',
//   },
// });

const urls = [
  'https://dev.to/nyxtom/introduction-to-crdts-for-realtime-collaboration-2eb1',
  'https://dev.to/foxgem/crdts-achieving-eventual-consistency-in-distributed-systems-296g',
  // "https://lilianweng.github.io/posts/2023-06-23-agent/",
];

const docs = await Promise.all(
  urls.map((url) =>
    new CheerioWebBaseLoader(url, {
      selector: '.crayons-layout__content',
      // selector: 'p'
    }).load(),
  ),
);
const docsList = docs.flat();

// const cheerioLoader = new CheerioWebBaseLoader(
//   "https://lilianweng.github.io/posts/2023-06-23-agent/",
//   {
//     selector: 'p'
//   }
// );
// const docsList = await cheerioLoader.load();

console.log(';; docsList ', docsList[0].pageContent.length);
// console.log(';; docsList ', docsList[0].pageContent.slice(0, 2200))

const textSplitter = new RecursiveCharacterTextSplitter({
  chunkSize: 500,
  chunkOverlap: 50,
});
const docSplits = await textSplitter.splitDocuments(docsList);
console.log(';; docSplits ', docSplits.length);
// console.log(';; docSplits ', docSplits.slice(0, 6))

// üõ¢Ô∏è save embeddings to vectorDB
// const vectorStore = new MemoryVectorStore(embeddings);
// await vectorStore.addDocuments(docSplits)
// const vectorStore = await MemoryVectorStore.fromDocuments(
//   docSplits,
//   embeddings
// );
const openAiClient = new OpenAIClient({
  apiKey: 'not-needed',
  baseURL: 'http://localhost:1234/v1',
});

// Create a proper embeddings interface for OpenAIClient
class OpenAIClientEmbeddings {
  constructor(
    private client: OpenAIClient,
    private model: string,
  ) {}

  async embedDocuments(texts: string[]): Promise<number[][]> {
    const response = await this.client.embeddings.create({
      model: this.model,
      input: texts,
      encoding_format: 'float',
    });
    return response.data.map((item) => item.embedding);
  }

  async embedQuery(text: string): Promise<number[]> {
    const embeddings = await this.embedDocuments([text]);
    return embeddings[0];
  }
}

// Create embeddings instance and use fromDocuments
const embeddingsInstance = new OpenAIClientEmbeddings(
  openAiClient,
  'text-embedding-qwen3-embedding-0.6b',
);
// const embeddingsInstance = new OpenAIClientEmbeddings(openAiClient, 'text-embedding-embeddinggemma-300m');
// const embeddingsInstance = new OpenAIClientEmbeddings(openAiClient, 'text-embedding-granite-embedding-278m-multilingual');
const vectorStore = await MemoryVectorStore.fromDocuments(
  docSplits,
  embeddingsInstance,
);

const retrieveSchema = z.object({ query: z.string() });

// turning retrieval step into a tool has another benefit, which is that the query for the retrieval is generated by our model.
// query analysis allows a model to rewrite user queries into more effective search queries
const retrieve = tool(
  async ({ query }) => {
    const retrievedDocs = await vectorStore.similaritySearch(query, 2);
    const serialized = retrievedDocs
      .map(
        (doc) => `Source: ${doc.metadata.source}\nContent: ${doc.pageContent}`,
      )
      .join('\n');
    return [serialized, retrievedDocs];
  },
  {
    name: 'retrieve',
    description: 'Retrieve information related to a query.',
    schema: retrieveSchema,
    responseFormat: 'content_and_artifact',
  },
);

const agent = createReactAgent({ llm: llm, tools: [retrieve] });

// ----------

const prettyPrint = (message: BaseMessage) => {
  let txt = `[${message.getType()}]: ${message.content}`;
  if ((isAIMessage(message) && message.tool_calls?.length) || 0 > 0) {
    const tool_calls = (message as AIMessage)?.tool_calls
      ?.map((tc) => `- ${tc.name}(${JSON.stringify(tc.args)})`)
      .join('\n');
    txt += ` \nTools: \n${tool_calls}`;
  }
  console.log(txt);
};

const inputMessage = `What is yjs? are there any popular products or companies or github repos using it ?`;

const inputs5 = { messages: [{ role: 'user', content: inputMessage }] };

for await (const step of await agent.stream(inputs5, {
  streamMode: 'values',
})) {
  const lastMessage = step.messages[step.messages.length - 1];
  console.log('\n------');
  prettyPrint(lastMessage);
}
